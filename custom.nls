; Opinion Dynamics
; bias - Initial Opinion bias
; mem - Memory
; tol - Tolerance range
to Opinions [bias mem tol]
  set-current-plot "Opinion clustering"
  clear-plot
  set-current-plot "General"
  clear-plot
  set-plot-y-range 0 1
  let t 0
  if Reset [init_opinions_cont]

  ; ad frequency
  let ad_freq (round (Iterations / (ad_count + 2)))

  repeat Iterations [
    set-current-plot "Opinion clustering"
    plotxy t Mean_Opinion_Clustering
    set-current-plot "General"

    ; print (word "Iteration " t)
    OpCh mem tol
    if Advertising and ((t mod ad_freq) = 0 and t != 0 and t != Iterations) [
      if ad_type = "random" [MassAd]
      if ad_type = "max_opinion" [MaxAd]
      if ad_type = "min_opinion" [MinAd]
      if ad_type = "hubs" [HubsAd]

      set-current-plot "General"
      plot-pen-up
      plotxy t 0
      plot-pen-down
      plotxy t plot-y-max

    ]
    ; Plot the average opinion
    let avg mean [current_state] of nodes
    plotxy t avg
    set t t + 1
  ]
end

; Opinion change
; mem - Memory
; tol - tolerance range
to OpCh [mem tol]
    no-display
    ask nodes [
        let s current_state
    
        if (Change_model = "voter") [
            if (count link-neighbors != 0) [
                new-state ([current_state] of (one-of link-neighbors))
            ]
        ]
        if (Change_model = "biased_average") [
            ; Take the average of neighbors' opinions withing a tolerance range
            ; tolerance range = 0.2
            let neighbors_opinions_sum sum ([current_state] of link-neighbors with [abs (current_state - s) <= 0.2])
            let neighbors_opinions_count count link-neighbors with [abs (current_state - s) <= 0.2]
            ifelse neighbors_opinions_count = 0 [
                new-state s
            ] [
                new-state neighbors_opinions_sum / neighbors_opinions_count
            ]
        ]
        let bias 0.03
        if (Change_model = "biased") [
            let neighbors_opinions_sum sum ([current_state] of link-neighbors)
            let neighbors_opinions_count count link-neighbors
            let nom memory * current_state + ((current_state ^ bias) * neighbors_opinions_sum)
            let denom memory + ((current_state ^ bias) * neighbors_opinions_sum) + ((1 - current_state) ^ bias) * (neighbors_opinions_count - neighbors_opinions_sum)
            new-state nom / denom
        ]
        set-state
    ]
    ask nodes [
        ; set-state
        set color scale-color blue current_state 0 1
    ]
    display
end


; Advertising

; Random advertising
; Nudge every node to 1 with a certain probability
to MassAd []
  ask (n-of (min (list ad_targets (count nodes))) nodes) [
    if random-float 1 < ad_effectiveness [
      let curr current_state
      new-state (min list (max list (curr + ad_effect) 0) 1)
      set-state
    ]
  ]
end

; Target those with max opinion
; Nudge nodes with opinion < 0 to 1 with a certain probability
to MaxAd []
  ask max-n-of (max (list ad_targets (count nodes))) nodes [current_state] [
    if random-float 1 < ad_effectiveness [
      let curr current_state
      new-state (min list (max list (curr + ad_effect) 0) 1)
      set-state
    ]
  ]
end

; Target those with min opinion
; Nudge nodes with opinion < 0 to 1 with a certain probability
to MinAd []
  ask min-n-of (max (list ad_targets (count nodes))) nodes [current_state] [
    if random-float 1 < ad_effectiveness [
      let curr current_state
      new-state (min list (max list (curr + ad_effect) 0) 1)
      set-state
    ]
  ]
end

; Target those with most neighbors
; Nudge nodes with opinion < 0 to 1 with a certain probability
to HubsAd []
  ask min-n-of (max (list ad_targets (count nodes))) nodes [count neighbors] [
    if random-float 1 < ad_effectiveness [
      let curr current_state
      new-state (min list (max list (curr + ad_effect) 0) 1)
      set-state
    ]
  ]
end


to-report Mean_Opinion
  report mean [current_state] of nodes
end

; Similar opinion clustering defined as ratio of neighbors with an opinion within a tolerance range
to-report Opinion_Clustering_Opinion
  let my-opinion current_state
  let neighbors-opinions [current_state] of link-neighbors
  let tolerance-range 0.1
  let count-within-range 0
  let total-neighbors length neighbors-opinions
  foreach neighbors-opinions [
    x -> if abs (x - my-opinion) <= tolerance-range [
      set count-within-range count-within-range + 1
    ]
  ]
  ifelse total-neighbors = 0 [
    report 0  ; Avoid division by zero
  ] [
    report count-within-range / total-neighbors
  ]
end

to-report Mean_Opinion_Clustering
  let sum-opinion-clustering 0
  ask nodes [
    set sum-opinion-clustering sum-opinion-clustering + Opinion_Clustering_Opinion
  ]
  report sum-opinion-clustering / count nodes
end

