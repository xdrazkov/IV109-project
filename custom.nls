; Opinion Dynamics
; Iter - Number of iterations
; bias - Initial Opinion bias
; mem - Memory
; Ad - Advertising - 0 for none, 1 for mass, 2 for targeted
; s - Strength of advertising
; p - Probability of influence
; tol - Tolerance range
to Opinions [Iter bias mem Ad s p tol]
  set-current-plot "General"
  clear-plot
  set-plot-y-range 0 1
  let t 0
  if Reset [init_opinions_cont]
  repeat Iter [
    ; print (word "Iteration " t)
    OpCh mem tol
    if Ad = 1 [MassAd s p]
    if Ad = 2 [TarAd s p]
    ; Plot the average opinion
    let avg mean [current_state] of nodes
    plotxy t avg
    set t t + 1
  ]
end

; Opinion change
; mem - Memory
; tol - tolerance range
to OpCh [mem tol]
    no-display
    ask nodes [
        let s current_state
    
        if (Change_model = "voter") [
            new-state ([current_state] of (one-of link-neighbors))
        ]
        if (Change_model = "majority") [
            new-state (round (sum ([current_state] of link-neighbors) / count link-neighbors))
        ]
        let bias 0.03
        if (Change_model = "biased") [
            let neighbors_opinions_sum sum ([current_state] of link-neighbors)
            let neighbors_opinions_count count link-neighbors
            let nom memory * current_state + ((current_state ^ bias) * neighbors_opinions_sum)
            let denom memory + ((current_state ^ bias) * neighbors_opinions_sum) + ((1 - current_state) ^ bias) * (neighbors_opinions_count - neighbors_opinions_sum)
            new-state nom / denom
        ]
        set-state
    ]
    ask nodes [
        ; set-state
        set color scale-color blue current_state 0 1
    ]
    display
end


; Advertising

; Mass advertising
; Nudge every node to 1 with a certain probability
; s - strength
; p - probability of influence
to MassAd [s p]
  ask nodes [
    if random-float 1 < p [
      let curr current_state
      ; TODO
      new-state (curr + s)
      set-state
    ]
  ]
end


; Targeted advertising
; Nudge nodes with opinion < 0 to 1 with a certain probability
; s - strength
; p - probability of influence
to TarAd [s p]
  ask nodes with [current_state < 0] [
    if random-float 1 < p [
      let curr current_state
      ; TODO
      new-state (curr + s)
      set-state
    ]
  ]
end


to-report Mean_Opinion
  report mean [current_state] of nodes
end

; Similar opinion clustering defined as ratio of neighbors with an opinion within a tolerance range
to-report Opinion_Clustering_Opinion
  let my-opinion current_state
  let neighbors-opinions [current_state] of link-neighbors
  let tolerance-range 0.1
  let count-within-range 0
  let total-neighbors length neighbors-opinions
  foreach neighbors-opinions [
    x -> if abs (x - my-opinion) <= tolerance-range [
      set count-within-range count-within-range + 1
    ]
  ]
  ifelse total-neighbors = 0 [
    report 0  ; Avoid division by zero
  ] [
    report count-within-range / total-neighbors
  ]
end

to-report Mean_Opinion_Clustering
  let sum-opinion-clustering 0
  ask nodes [
    set sum-opinion-clustering sum-opinion-clustering + Opinion_Clustering_Opinion
  ]
  report sum-opinion-clustering / count nodes
end

